import {
  createRunOncePlugin,
  AndroidConfig,
  withInfoPlist,
  withAndroidManifest,
  withXcodeProject,
  withDangerousMod,
  type ConfigPlugin,
} from 'expo/config-plugins';
import * as fs from 'fs';
import * as path from 'path';

import { PluginConfigType, validateConfig } from './pluginConfig';

const pkg = require('../../package.json');

/**
 * Adds an SPM dependency on ConvexMobile (from convex-swift) to the main app target.
 * This replaces the previous CocoaPods-based approach with Swift Package Manager.
 */
const withConvexSPM: ConfigPlugin = (config) => {
  return withXcodeProject(config, (config) => {
    const project = config.modResults;
    const targetName = config.modRequest.projectName;

    const REPO_URL = 'https://github.com/get-convex/convex-swift';
    const REPO_NAME = 'convex-swift';
    const PRODUCT_NAME = 'ConvexMobile';
    const MIN_VERSION = '0.8.1';

    // --- Step 1: XCRemoteSwiftPackageReference ---
    if (!project.hash.project.objects['XCRemoteSwiftPackageReference']) {
      project.hash.project.objects['XCRemoteSwiftPackageReference'] = {};
    }

    const packageReferenceUUID = project.generateUuid();
    const packageRefKey = `${packageReferenceUUID} /* XCRemoteSwiftPackageReference "${REPO_NAME}" */`;

    project.hash.project.objects['XCRemoteSwiftPackageReference'][packageRefKey] = {
      isa: 'XCRemoteSwiftPackageReference',
      repositoryURL: REPO_URL,
      requirement: {
        kind: 'upToNextMajorVersion',
        minimumVersion: MIN_VERSION,
      },
    };

    // --- Step 2: XCSwiftPackageProductDependency ---
    if (!project.hash.project.objects['XCSwiftPackageProductDependency']) {
      project.hash.project.objects['XCSwiftPackageProductDependency'] = {};
    }

    const packageUUID = project.generateUuid();
    const productKey = `${packageUUID} /* ${PRODUCT_NAME} */`;

    project.hash.project.objects['XCSwiftPackageProductDependency'][productKey] = {
      isa: 'XCSwiftPackageProductDependency',
      package: packageRefKey,
      productName: PRODUCT_NAME,
    };

    // --- Step 3: Add packageReferences to PBXProject ---
    const projectId = Object.keys(
      project.hash.project.objects['PBXProject']
    ).find((key) => !key.endsWith('_comment'));

    if (projectId) {
      if (!project.hash.project.objects['PBXProject'][projectId]['packageReferences']) {
        project.hash.project.objects['PBXProject'][projectId]['packageReferences'] = [];
      }
      project.hash.project.objects['PBXProject'][projectId]['packageReferences'].push(
        packageRefKey
      );
    }

    // --- Step 4: Add PBXBuildFile entry ---
    const frameworkUUID = project.generateUuid();
    const frameworkCommentKey = `${frameworkUUID}_comment`;

    project.hash.project.objects['PBXBuildFile'][frameworkCommentKey] =
      `${PRODUCT_NAME} in Frameworks`;
    project.hash.project.objects['PBXBuildFile'][frameworkUUID] = {
      isa: 'PBXBuildFile',
      productRef: packageUUID,
      productRef_comment: PRODUCT_NAME,
    };

    // --- Step 5: Add to PBXFrameworksBuildPhase for the main app target ---
    const nativeTargetId = project.findTargetKey(targetName ?? '');
    if (nativeTargetId) {
      const frameworksBuildPhase = project.pbxFrameworksBuildPhaseObj(nativeTargetId);
      if (frameworksBuildPhase) {
        frameworksBuildPhase.files.push({
          value: frameworkUUID,
          comment: `${PRODUCT_NAME} in Frameworks`,
        });
      }
    }

    // --- Step 6: Add packageProductDependencies to the native target ---
    if (nativeTargetId) {
      const nativeTarget = project.pbxNativeTargetSection()[nativeTargetId];
      if (nativeTarget) {
        if (!nativeTarget.packageProductDependencies) {
          nativeTarget.packageProductDependencies = [];
        }
        nativeTarget.packageProductDependencies.push(productKey);
      }
    }

    return config;
  });
};

/**
 * Generates the ConvexMagentsProvider.swift bridge file in the consumer app's iOS directory.
 * This file implements the MagentsDataProvider protocol and registers itself with MagentsDataStore.
 */
const withConvexBridge: ConfigPlugin = (config) => {
  return withDangerousMod(config, [
    'ios',
    (config) => {
      const appName = config.modRequest.projectName ?? '';
      const bridgePath = path.join(
        config.modRequest.platformProjectRoot,
        appName,
        'ConvexMagentsProvider.swift'
      );

      // Avoid overwriting on repeated prebuild runs
      if (fs.existsSync(bridgePath)) {
        return config;
      }

      const bridgeContent = `// AUTO-GENERATED by expo-dev-launcher config plugin â€” do not edit
import ConvexMobile
import Combine
import Foundation

@MainActor
final class ConvexMagentsProvider: MagentsDataProvider {
    private let client: ConvexClient?
    private var cancellables = Set<AnyCancellable>()

    init() {
        guard let url = Bundle.main.infoDictionary?["ConvexDeploymentUrl"] as? String,
              !url.isEmpty else {
            client = nil
            return
        }
        client = ConvexClient(deploymentUrl: url)
    }

    func startSubscription() {
        guard let client else { return }

        client.subscribe(to: "items:list", yielding: [ConvexItem].self)
            .replaceError(with: [])
            .receive(on: DispatchQueue.main)
            .sink { items in
                MagentsDataStore.shared.update(items: items.map {
                    MagentsItem(id: $0._id, text: $0.text, isCompleted: $0.isCompleted)
                })
            }
            .store(in: &cancellables)
    }

    func addItem(text: String) async throws {
        guard let client else { return }
        let _: String? = try await client.mutation("items:add", with: ["text": text])
    }

    func toggleItem(id: String) async throws {
        guard let client else { return }
        let _: String? = try await client.mutation("items:toggle", with: ["id": id])
    }

    func removeItem(id: String) async throws {
        guard let client else { return }
        let _: String? = try await client.mutation("items:remove", with: ["id": id])
    }
}

/// Mirrors the Convex document shape for decoding.
private struct ConvexItem: Decodable {
    let _id: String
    let text: String
    let isCompleted: Bool
}

/// Registers the Convex provider at app launch.
private enum ConvexMagentsBootstrap {
    static let _: Void = {
        Task { @MainActor in
            MagentsDataStore.register(provider: ConvexMagentsProvider())
        }
    }()
}
`;

      fs.mkdirSync(path.dirname(bridgePath), { recursive: true });
      fs.writeFileSync(bridgePath, bridgeContent, 'utf8');

      return config;
    },
  ]);
};

/**
 * Injects the Convex deployment URL into Info.plist as `ConvexDeploymentUrl`.
 * This allows the native Swift code to read the URL at runtime via Bundle.main.
 */
const withConvexInfoPlist: ConfigPlugin<string> = (config, convexUrl) => {
  return withInfoPlist(config, (config) => {
    config.modResults['ConvexDeploymentUrl'] = convexUrl;
    return config;
  });
};

/**
 * Adds a build phase script that strips dev-launcher-specific local network permission keys
 * from non-Debug builds. This keeps the keys in Debug builds (where dev-launcher is active)
 * but removes only the dev-launcher entries from production builds.
 *
 * IMPORTANT: This script only removes _expo._tcp Bonjour services and the dev-launcher
 * usage description. Any other Bonjour services or custom local network descriptions
 * added by the app will be preserved in production builds.
 */
const withStripLocalNetworkKeysForRelease: ConfigPlugin = (config) => {
  return withXcodeProject(config, (config) => {
    const project = config.modResults;
    const targetName = config.modRequest.projectName;

    const nativeTargetId = project.findTargetKey(targetName ?? '');
    if (!nativeTargetId) {
      console.warn(
        `[Expo Dev Launcher] Could not find target "${targetName}" to add build phase script`
      );
      return config;
    }

    const buildPhaseName = '[Expo Dev Launcher] Strip Local Network Keys for Release';

    const buildPhases = project.pbxNativeTargetSection()[nativeTargetId]?.buildPhases ?? [];
    const existingPhase = buildPhases.find((phase: { comment?: string }) => {
      return phase.comment === buildPhaseName;
    });

    if (existingPhase) {
      return config;
    }

    project.addBuildPhase([], 'PBXShellScriptBuildPhase', buildPhaseName, nativeTargetId, {
      shellPath: '/bin/sh',
      shellScript: `# Strip dev-launcher-specific local network permission keys from non-Debug builds
# This only removes _expo._tcp Bonjour services and the dev-launcher usage description.
# Other Bonjour services and custom descriptions are preserved for production use.

if [ "$CONFIGURATION" != "Debug" ]; then
  PLIST_PATH="\${TARGET_BUILD_DIR}/\${INFOPLIST_PATH}"
  if [ -f "$PLIST_PATH" ]; then
    # Check if NSBonjourServices exists
    if /usr/libexec/PlistBuddy -c "Print :NSBonjourServices" "$PLIST_PATH" >/dev/null 2>&1; then
      # Get the count of services
      COUNT=$(/usr/libexec/PlistBuddy -c "Print :NSBonjourServices" "$PLIST_PATH" 2>/dev/null | grep "^    " | wc -l | tr -d ' ')

      # Remove _expo._tcp
      for ((i=COUNT-1; i>=0; i--)); do
        SERVICE=$(/usr/libexec/PlistBuddy -c "Print :NSBonjourServices:$i" "$PLIST_PATH" 2>/dev/null || echo "")
        if echo "$SERVICE" | grep -q "_expo._tcp"; then
          /usr/libexec/PlistBuddy -c "Delete :NSBonjourServices:$i" "$PLIST_PATH" 2>/dev/null || true
        fi
      done

      # If the array is now empty, remove it entirely
      REMAINING=$(/usr/libexec/PlistBuddy -c "Print :NSBonjourServices" "$PLIST_PATH" 2>/dev/null | grep "^    " | wc -l | tr -d ' ')
      if [ "$REMAINING" -eq "0" ]; then
        /usr/libexec/PlistBuddy -c "Delete :NSBonjourServices" "$PLIST_PATH" 2>/dev/null || true
      fi
    fi

    # Only delete the description if it matches the dev-launcher default text
    DESC=$(/usr/libexec/PlistBuddy -c "Print :NSLocalNetworkUsageDescription" "$PLIST_PATH" 2>/dev/null || echo "")
    if echo "$DESC" | grep -q "Expo Dev Launcher"; then
      /usr/libexec/PlistBuddy -c "Delete :NSLocalNetworkUsageDescription" "$PLIST_PATH" 2>/dev/null || true
    fi
  fi
fi
`,
    });

    return config;
  });
};

/**
 * Adds the required Info.plist keys for local network permission.
 * Only adds _expo._tcp to the Bonjour services array and sets the usage description
 * if one doesn't already exist (preserving custom descriptions).
 */
const withLocalNetworkPermission: ConfigPlugin = (config) => {
  return withInfoPlist(config, (config) => {
    const bonjourServices = (config.modResults.NSBonjourServices as string[] | undefined) ?? [];

    const hasExpoService = bonjourServices.some(
      (service) => service.toLowerCase().replace(/\.$/, '') === '_expo._tcp'
    );

    if (!hasExpoService) {
      bonjourServices.push('_expo._tcp');
    }
    config.modResults.NSBonjourServices = bonjourServices;

    if (!config.modResults.NSLocalNetworkUsageDescription) {
      config.modResults.NSLocalNetworkUsageDescription =
        'Expo Dev Launcher uses the local network to discover and connect to development servers running on your computer.';
    }

    return config;
  });
};

export default createRunOncePlugin<PluginConfigType>(
  (config, props = {}) => {
    validateConfig(props);

    const iOSLaunchMode =
      props.ios?.launchMode ??
      props.launchMode ??
      props.ios?.launchModeExperimental ??
      props.launchModeExperimental;
    if (iOSLaunchMode === 'launcher') {
      config = withInfoPlist(config, (config) => {
        config.modResults['DEV_CLIENT_TRY_TO_LAUNCH_LAST_BUNDLE'] = false;
        return config;
      });
    }

    const androidLaunchMode =
      props.android?.launchMode ??
      props.launchMode ??
      props.android?.launchModeExperimental ??
      props.launchModeExperimental;
    if (androidLaunchMode === 'launcher') {
      config = withAndroidManifest(config, (config) => {
        const mainApplication = AndroidConfig.Manifest.getMainApplicationOrThrow(config.modResults);

        AndroidConfig.Manifest.addMetaDataItemToMainApplication(
          mainApplication,
          'DEV_CLIENT_TRY_TO_LAUNCH_LAST_BUNDLE',
          false?.toString()
        );
        return config;
      });
    }

    config = withLocalNetworkPermission(config);
    config = withStripLocalNetworkKeysForRelease(config);

    // Convex integration (conditional on convexUrl)
    if (props.convexUrl) {
      config = withConvexSPM(config);
      config = withConvexBridge(config);
      config = withConvexInfoPlist(config, props.convexUrl);
    }

    return config;
  },
  pkg.name,
  pkg.version
);
